import cv2
import numpy as np
import imutils
import colours

def img_warp(img, points, w, h):
    '''
    main warping function using transformation matrix built into cv2
    imputs:
        img: cv2 image object
        points: points generated by warp trackbars
        w: window width
        h: window height
    '''
    pts1 = np.float32(points)
    pts2 = np.float32([[0,0], [w,0], [0,h], [w,h]])
    matrix = cv2.getPerspectiveTransform(pts1, pts2)
    img_warp = cv2.warpPerspective(img, matrix, (w,h))
    return img_warp

def nothing(a):
    pass

def trackbar_init(initTVals, wt=480, ht=240):
    '''
    initialises trackbar window (called trackbars) with values width top/bottom and height top/bottom
    currently only used in perspective warp
    '''
    cv2.namedWindow("trackbars")
    cv2.resizeWindow("trackbars", 360, 240)
    cv2.createTrackbar("width top", "trackbars", initTVals[0], wt//2, nothing)
    cv2.createTrackbar("height top", "trackbars", initTVals[1], ht, nothing)
    cv2.createTrackbar("width bottom", "trackbars", initTVals[2], wt//2, nothing)
    cv2.createTrackbar("height bottom", "trackbars", initTVals[3], ht, nothing)

def trackbar_val(wt=480, ht=240):
    '''
    retrieves data from trackbars window
    currently only used in perspective warp
    '''
    width_top = cv2.getTrackbarPos("width top", "trackbars")
    height_top = cv2.getTrackbarPos("height top", "trackbars")
    width_bottom = cv2.getTrackbarPos("width bottom", "trackbars")
    height_bottom = cv2.getTrackbarPos("height bottom", "trackbars")
    points = np.float32([(width_top, height_top), (wt - width_top, height_top), 
                         (width_bottom, height_bottom), (wt - width_bottom, height_bottom)])

    return points

# def detect_arrow(img, arrow):


def thresholding(img, colour):
    imgHsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    testBlue = cv2.inRange(imgHsv, colour.lower, colour.upper)
    return testBlue